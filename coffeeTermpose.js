// Generated by CoffeeScript 1.8.0
(function() {
  var Parser, Term, asList, escapeSymbol, mightBeReservedChar, parseTermpose,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  asList = function(ps) {
    var root, term, _i, _len;
    root = [];
    for (_i = 0, _len = ps.length; _i < _len; _i++) {
      term = ps[_i];
      if (term.tail) {
        root.push([root.term].concat(asList(term.tail)));
      } else {
        root.push([root.term]);
      }
    }
    return root;
  };

  mightBeReservedChar = function(c) {
    return c.charCodeAt(0) < 59;
  };

  escapeSymbol = function(str) {
    var c, sb, _i, _len;
    sb = '';
    for (_i = 0, _len = str.length; _i < _len; _i++) {
      c = str[_i];
      switch (c) {
        case '\\':
          sb += '\\\\';
          break;
        case '"':
          sb += '\\"';
          break;
        case '\n':
          sb += '\\n';
          break;
        case '\r':
          sb += '\\r';
          break;
        default:
          sb += c;
      }
    }
    return sb;
  };

  Term = (function() {
    var parse;

    parse = function(str) {
      return new Parser().parse(str);
    };

    function Term(v, tail) {
      this.v = v;
      this.tail = tail != null ? tail : [];
    }

    Term.prototype.getMap = function() {
      var mappables, t, _i, _len, _ref;
      if (!this.asMap) {
        mappables = [];
        _ref = this.tail;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          t = _ref[_i];
          if (t.tail.length >= 1 && t.tail[0].tail.length === 0) {
            mappables.push(t);
          }
        }
        this.asMap = new Map(mappables.map(function(t) {
          return [t.v, t.tail[0].v];
        }));
      }
      return this.asMap;
    };

    Term.prototype.get = function(k) {
      return this.getMap().get(k);
    };

    Term.prototype.at = function(i) {
      return this.tail[i];
    };

    Term.prototype.stringifySymbol = function() {
      var c, needsBeEscaped, _i, _len, _ref;
      needsBeEscaped = false;
      _ref = this.v;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        c = _ref[_i];
        needsBeEscaped = mightBeReservedChar(c) && (function() {
          switch (c) {
            case ' ':
              return true;
            case '(':
              return true;
            case ':':
              return true;
            case '\t':
              return true;
            case '\n':
              return true;
            case '\r':
              return true;
            case ')':
              return true;
            default:
              return false;
          }
        })();
        if (needsBeEscaped) {
          break;
        }
      }
      if (needsBeEscaped) {
        return '"' + (escapeSymbol(this.v)) + '"';
      } else {
        return this.v;
      }
    };

    Term.prototype.toString = function() {
      if (this.tail.length) {
        return this.stringifySymbol() + '(' + this.tail.map(function(t) {
          return t.toString();
        }).join(' ') + ')';
      } else {
        return this.stringifySymbol();
      }
    };

    return Term;

  })();

  Parser = (function() {
    var startsWith;

    function Parser() {
      this.multiLineTakingText = __bind(this.multiLineTakingText, this);
      this.multiLineTakingIndent = __bind(this.multiLineTakingIndent, this);
      this.multiLineFirstLine = __bind(this.multiLineFirstLine, this);
      this.takingEscape = __bind(this.takingEscape, this);
      this.takingSingleLineQuoteTerm = __bind(this.takingSingleLineQuoteTerm, this);
      this.startingToTakeQuoteTerm = __bind(this.startingToTakeQuoteTerm, this);
      this.seekingColonBuddy = __bind(this.seekingColonBuddy, this);
      this.enteringParen = __bind(this.enteringParen, this);
      this.takeTerm = __bind(this.takeTerm, this);
      this.seekingInLine = __bind(this.seekingInLine, this);
      this.eatingIndentation = __bind(this.eatingIndentation, this);
      this.openParen = __bind(this.openParen, this);
      this.closeParen = __bind(this.closeParen, this);
      this.finishLine = __bind(this.finishLine, this);
      this.finishTakingIndentation = __bind(this.finishTakingIndentation, this);
      this.finishTakingTermAndAttach = __bind(this.finishTakingTermAndAttach, this);
      this.finishTakingSymbol = __bind(this.finishTakingSymbol, this);
      this.init();
    }

    Parser.prototype.init = function() {
      this.stringBuffer = "";
      this.foremostSymbol = "";
      this.salientIndentation = "";
      this.resultSeq = [];
      this.headTerm = null;
      this.foremostTerm = null;
      this.parenTermStack = [];
      this.tailestTermSequence = this.resultSeq;
      this.parenParentStack = [];
      this.line = 0;
      this.column = 0;
      this.index = 0;
      this.currentMode = null;
      this.modes = [];
      this.indentStack = [[0, this.resultSeq]];
      this.previousIndentation = "";
      this.multiLineIndent = "";
      this.mlIndent = null;
      return this.containsImmediateNext = null;
    };

    startsWith = function(string, prefix) {
      var eqs, i;
      if (prefix.length > string.length) {
        return true;
      } else {
        i = 0;
        while (i < prefix.length) {
          eqs = string.charCodeAt(i) === prefix.charCodeAt(i);
          if (!eqs) {
            return false;
          }
          i += 1;
        }
        return true;
      }
    };

    Parser.prototype.interTerm = function(symbol) {
      var t;
      t = new Term(symbol, []);
      t.line = this.line;
      t.column = this.column;
      return t;
    };

    Parser.prototype.transition = function(nm) {
      return this.currentMode = nm;
    };

    Parser.prototype.pushMode = function(nm) {
      this.modes.push(this.currentMode);
      return this.transition(nm);
    };

    Parser.prototype.popMode = function() {
      return this.currentMode = this.modes.pop();
    };

    Parser.prototype.die = function(message, l, c) {
      if (l == null) {
        l = this.line;
      }
      if (c == null) {
        c = this.column;
      }
      throw new Error("line:" + l + " column:" + c + ", no, bad: " + message);
    };

    Parser.prototype.finishTakingSymbol = function() {
      this.foremostSymbol = this.stringBuffer;
      this.stringBuffer = '';
      return this.foremostSymbol;
    };

    Parser.prototype.finishTakingTermAndAttach = function() {
      this.foremostTerm = this.interTerm(this.finishTakingSymbol());
      if (this.containsImmediateNext) {
        this.containsImmediateNext.tail.push(this.foremostTerm);
        return this.containsImmediateNext = null;
      } else if (this.headTerm === null) {
        this.headTerm = this.foremostTerm;
        this.indentStack[this.indentStack.length - 1][1].push(this.foremostTerm);
        return this.tailestTermSequence = this.foremostTerm.tail;
      } else if (this.parenTermStack.length === 0) {
        return this.headTerm.tail.push(this.foremostTerm);
      } else {
        return this.parenTermStack[0].tail.push(this.foremostTerm);
      }
    };

    Parser.prototype.finishTakingIndentation = function() {
      this.previousIndentation = this.salientIndentation;
      this.salientIndentation = this.stringBuffer;
      if (this.salientIndentation.length > this.previousIndentation.length) {
        if (!startsWith(this.salientIndentation, this.previousIndentation)) {
          this.die("inconsistent indentation at", this.headTerm.line, this.headTerm.column);
        }
        this.indentStack.push([this.salientIndentation.length, this.tailestTermSequence]);
      } else if (this.salientIndentation.length < this.previousIndentation.length) {
        if (!startsWith(this.previousIndentation, this.salientIndentation)) {
          this.die("inconsistent indentation", this.headTerm.line, this.headTerm.column);
        }
        while (this.indentStack[this.indentStack.length - 1][0] > this.salientIndentation.length) {
          if (this.indentStack[this.indentStack.length - 1][0] < this.salientIndentation.length) {
            this.die("inconsistent indentation, sibling elements have different indentation", this.headTerm.line, this.headTerm.column);
          }
          this.indentStack.pop();
        }
      }
      this.stringBuffer = '';
      return this.salientIndentation;
    };

    Parser.prototype.finishLine = function() {
      this.containsImmediateNext = null;
      this.parenTermStack = [];
      this.headTerm = null;
      return this.foremostTerm = null;
    };

    Parser.prototype.closeParen = function() {
      if (this.parenTermStack.length === 0) {
        this.die("unbalanced paren");
      }
      this.parenTermStack.pop();
      return this.transition(this.seekingInLine);
    };

    Parser.prototype.openParen = function() {
      this.parenTermStack.push(this.foremostTerm);
      return this.transition(this.enteringParen);
    };

    Parser.prototype.eatingIndentation = function(fileEnd, c) {
      var stringBuffer;
      if (!fileEnd) {
        switch (c) {
          case '\n':
            return stringBuffer = '';
          case ':':
            return this.die("colon not allowed here");
          case '(':
            return this.die("what are you openingggg");
          case ')':
            return this.die("what are you closingggg");
          case '"':
            this.finishTakingIndentation();
            return this.transition(this.startingToTakeQuoteTerm);
          case ' ':
            return this.stringBuffer += c;
          case '\t':
            return this.stringBuffer += c;
          default:
            this.finishTakingIndentation();
            this.transition(this.takeTerm);
            return this.takeTerm(false, c);
        }
      }
    };

    Parser.prototype.seekingInLine = function(fileEnd, c) {
      if (!fileEnd) {
        switch (c) {
          case '(':
            return this.openParen();
          case ')':
            return this.closeParen();
          case ':':
            this.containsImmediateNext = this.foremostTerm;
            return this.transition(this.seekingColonBuddy);
          case ' ':
            break;
          case '\t':
            break;
          case '\n':
            this.finishLine();
            return this.transition(this.eatingIndentation);
          case '"':
            return this.transition(this.startingToTakeQuoteTerm);
          default:
            this.transition(this.takeTerm);
            return this.takeTerm(false, c);
        }
      }
    };

    Parser.prototype.takeTerm = function(fileEnd, c) {
      var breakToSeekingInline;
      if (fileEnd) {
        return this.finishTakingTermAndAttach();
      } else {
        breakToSeekingInline = (function(_this) {
          return function() {
            _this.finishTakingTermAndAttach();
            _this.transition(_this.seekingInLine);
            return _this.seekingInLine(false, c);
          };
        })(this);
        switch (c) {
          case ' ':
            return breakToSeekingInline();
          case '\t':
            return breakToSeekingInline();
          case ':':
            return breakToSeekingInline();
          case '\n':
            return breakToSeekingInline();
          case '(':
            return breakToSeekingInline();
          case ')':
            return breakToSeekingInline();
          case '"':
            this.finishTakingTermAndAttach();
            this.containsImmediateNext = this.foremostTerm;
            return this.transition(this.startingToTakeQuoteTerm);
          default:
            return this.stringBuffer += c;
        }
      }
    };

    Parser.prototype.enteringParen = function(fileEnd, c) {
      if (fileEnd) {
        return this.die("end of file before paren close, this has no meaning and does not make sense.");
      } else {
        switch (c) {
          case ' ':
            break;
          case '\t':
            break;
          case ':':
            return this.die("colon wat");
          case '(':
            return this.die("paren opens nothing");
          case ')':
            return this.closeParen();
          case '"':
            return this.transition(this.takingSingleLineQuoteTerm);
          case '\n':
            return this.die("newline before paren completion (parens are only for single lines)");
          default:
            this.transition(this.takeTerm);
            return this.takeTerm(false, c);
        }
      }
    };

    Parser.prototype.seekingColonBuddy = function(fileEnd, c) {
      if (fileEnd) {
        return this.die("end of file after a colon, this has no meaning and does not make sense");
      } else {
        switch (c) {
          case ' ':
            break;
          case '\t':
            break;
          case ':':
            return this.die("double colon wat");
          case '\n':
            this.tailestTermSequence = this.containsImmediateNext.tail;
            this.finishLine();
            return this.transition(this.eatingIndentation);
          case '(':
            return this.openParen();
          case ')':
            return this.die("closebracket after colon wat");
          case '"':
            return this.transition(this.startingToTakeQuoteTerm);
          default:
            this.transition(this.takeTerm);
            return this.takeTerm(false, c);
        }
      }
    };

    Parser.prototype.startingToTakeQuoteTerm = function(fileEnd, c) {
      if (fileEnd) {
        return this.finishTakingTermAndAttach();
      } else {
        switch (c) {
          case '"':
            this.finishTakingTermAndAttach();
            return this.transition(this.seekingInLine);
          case '\n':
            return this.transition(this.multiLineFirstLine);
          default:
            this.transition(this.takingSingleLineQuoteTerm);
            return this.takingSingleLineQuoteTerm(false, c);
        }
      }
    };

    Parser.prototype.takingSingleLineQuoteTerm = function(fileEnd, c) {
      if (fileEnd) {
        return this.finishTakingTermAndAttach();
      } else {
        switch (c) {
          case '"':
            this.finishTakingTermAndAttach();
            return this.transition(this.seekingInLine);
          case '\\':
            return this.pushMode(this.takingEscape);
          case '\n':
            this.finishTakingTermAndAttach();
            this.transition(this.seekingInLine);
            return this.seekingInLine(fileEnd, '\n');
          default:
            return this.stringBuffer += c;
        }
      }
    };

    Parser.prototype.takingEscape = function(fileEnd, c) {
      if (fileEnd) {
        return this.die("invalid escape sequence, no one can escape the end of the file");
      } else {
        switch (c) {
          case 'h':
            this.stringBuffer += '☃';
            break;
          case 'n':
            this.stringBuffer += '\n';
            break;
          case 'r':
            this.stringBuffer += '\r';
            break;
          case 't':
            this.stringBuffer += '\t';
            break;
          default:
            this.stringBuffer += c;
        }
        return this.popMode();
      }
    };

    Parser.prototype.multiLineFirstLine = function(fileEnd, c) {
      if (fileEnd) {
        return this.finishTakingTermAndAttach();
      } else {
        switch (c) {
          case ' ':
            return this.multiLineIndent += c;
          case '\t':
            return this.multiLineIndent += c;
          default:
            this.mlIndent = this.multiLineIndent;
            if (this.mlIndent.length > this.salientIndentation.length) {
              if (startsWith(this.mlIndent, this.salientIndentation)) {
                this.multiLineIndent = '';
                this.transition(this.multiLineTakingText);
                return this.multiLineTakingText(false, c);
              } else {
                return this.die("inconsistent indentation");
              }
            } else {
              this.finishTakingTermAndAttach();
              this.finishLine();
              this.stringBuffer = this.mlIndent;
              this.mlIndent = null;
              this.transition(this.eatingIndentation);
              return this.eatingIndentation(false, c);
            }
        }
      }
    };

    Parser.prototype.multiLineTakingIndent = function(fileEnd, c) {
      var minb;
      if (fileEnd) {
        return this.finishTakingTermAndAttach();
      } else if (c === ' ' || c === '\t') {
        this.multiLineIndent += c;
        minb = this.multiLineIndent;
        if (minb.length === this.mlIndent.length) {
          if (startsWith(minb, this.mlIndent)) {
            this.stringBuffer += '\n';
            this.multiLineIndent = '';
            return this.transition(this.multiLineTakingText);
          } else {
            return this.die("inconsistent indentation");
          }
        }
      } else if (startsWith(this.mlIndent, minb)) {
        this.finishTakingTermAndAttach();
        this.finishLine();
        this.stringBuffer = this.mlIndent;
        this.transition(this.eatingIndentation);
        return this.eatingIndentation(false, c);
      } else {
        return this.die("inconsistent indentation");
      }
    };

    Parser.prototype.multiLineTakingText = function(fileEnd, c) {
      if (fileEnd) {
        return this.finishTakingTermAndAttach();
      } else {
        switch (c) {
          case '\n':
            return this.transition(this.multiLineTakingIndent);
          default:
            return this.stringBuffer += c;
        }
      }
    };

    Parser.prototype.parse = function(s) {
      var c, res;
      this.transition(this.eatingIndentation);
      while (this.index < s.length) {
        c = s[this.index];
        if (c === '\r') {
          if (s[this.index + 1] === '\n') {
            this.index += 1;
          }
          c = '\n';
        }
        this.currentMode(false, c);
        this.index += 1;
        if (c === '\n') {
          this.line += 1;
          this.column = 0;
        } else {
          this.column += 1;
        }
      }
      this.currentMode(true, '☠');
      res = this.resultSeq;
      this.init();
      return res;
    };

    return Parser;

  })();

  parseTermpose = function(s) {
    return new Parser().parse(s);
  };

  exports.parseTermpose = parseTermpose;

  exports.Term = Term;

  exports.Parser = Parser;

}).call(this);
