// Generated by CoffeeScript 1.8.0
(function() {
  var Parser, Term, asList, escapeSymbol, mightBeReservedChar, parseTermpose,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  asList = function(ps) {
    var root, term, _i, _len;
    root = [];
    for (_i = 0, _len = ps.length; _i < _len; _i++) {
      term = ps[_i];
      if (term.tail) {
        root.push([root.term].concat(asList(term.tail)));
      } else {
        root.push([root.term]);
      }
    }
    return root;
  };

  mightBeReservedChar = function(c) {
    return c.charCodeAt(0) < 59;
  };

  escapeSymbol = function(str) {
    var c, sb, _i, _len;
    sb = '';
    for (_i = 0, _len = str.length; _i < _len; _i++) {
      c = str[_i];
      switch (c) {
        case '\\':
          sb += '\\\\';
          break;
        case '"':
          sb += '\\"';
          break;
        case '\n':
          sb += '\\n';
          break;
        case '\r':
          sb += '\\r';
          break;
        default:
          sb += c;
      }
    }
    return sb;
  };

  Term = (function() {
    function Term(v, tail) {
      this.v = v;
      this.tail = tail != null ? tail : [];
    }

    Term.prototype.getMap = function() {
      var mappables, t, _i, _len, _ref;
      if (!this.asMap) {
        mappables = [];
        _ref = this.tail;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          t = _ref[_i];
          if (t.tail.length >= 1 && t.tail[0].tail.length === 0) {
            mappables.push(t);
          }
        }
        this.asMap = new Map(mappables.map(function(t) {
          return [t.v, t.tail[0].v];
        }));
      }
      return this.asMap;
    };

    Term.prototype.get = function(k) {
      return this.getMap().get(k);
    };

    Term.prototype.at = function(i) {
      return this.tail[i];
    };

    Term.prototype.stringifySymbol = function() {
      var c, needsBeEscaped, _i, _len, _ref;
      needsBeEscaped = false;
      _ref = this.v;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        c = _ref[_i];
        needsBeEscaped = mightBeReservedChar(c) && (function() {
          switch (c) {
            case ' ':
              return true;
            case '(':
              return true;
            case ':':
              return true;
            case '\t':
              return true;
            case '\n':
              return true;
            case '\r':
              return true;
            case ')':
              return true;
            default:
              return false;
          }
        })();
        if (needsBeEscaped) {
          break;
        }
      }
      if (needsBeEscaped) {
        return '"' + (escapeSymbol(this.v)) + '"';
      } else {
        return this.v;
      }
    };

    Term.prototype.toString = function() {
      if (this.tail.length) {
        return this.stringifySymbol() + '(' + this.tail.map(function(t) {
          return t.toString();
        }).join(' ') + ')';
      } else {
        return this.stringifySymbol();
      }
    };

    return Term;

  })();

  Parser = (function() {
    var startsWith;

    function Parser() {
      this.multiLineTakingText = __bind(this.multiLineTakingText, this);
      this.multiLineTakingIndent = __bind(this.multiLineTakingIndent, this);
      this.multiLineFirstLine = __bind(this.multiLineFirstLine, this);
      this.takingEscape = __bind(this.takingEscape, this);
      this.takingSingleLineQuoteTerm = __bind(this.takingSingleLineQuoteTerm, this);
      this.startingToTakeQuoteTerm = __bind(this.startingToTakeQuoteTerm, this);
      this.seekingColonBuddy = __bind(this.seekingColonBuddy, this);
      this.enteringParen = __bind(this.enteringParen, this);
      this.takeTerm = __bind(this.takeTerm, this);
      this.seekingInLine = __bind(this.seekingInLine, this);
      this.eatingIndentation = __bind(this.eatingIndentation, this);
      this.openParen = __bind(this.openParen, this);
      this.closeParen = __bind(this.closeParen, this);
      this.finishLineNormally = __bind(this.finishLineNormally, this);
      this.finishLine = __bind(this.finishLine, this);
      this.finishTakingIndentation = __bind(this.finishTakingIndentation, this);
      this.finishTakingTermAndAttach = __bind(this.finishTakingTermAndAttach, this);
      this.finishTakingSymbol = __bind(this.finishTakingSymbol, this);
      this.init();
    }

    Parser.prototype.init = function() {
      this.stringBuffer = "";
      this.foremostSymbol = "";
      this.salientIndentation = "";
      this.resultSeq = [];
      this.headTerm = null;
      this.foremostTerm = null;
      this.parenTermStack = [];
      this.tailestTermSequence = this.resultSeq;
      this.parenParentStack = [];
      this.line = 0;
      this.column = 0;
      this.index = 0;
      this.currentMode = null;
      this.modes = [];
      this.indentStack = [[0, this.resultSeq]];
      this.previousIndentation = "";
      this.previousTailestTermSequence = this.resultSeq;
      this.multiLineIndent = "";
      this.mlIndent = null;
      return this.containsImmediateNext = null;
    };

    startsWith = function(string, prefix) {
      var eqs, i;
      if (prefix.length > string.length) {
        return true;
      } else {
        i = 0;
        while (i < prefix.length) {
          eqs = string.charCodeAt(i) === prefix.charCodeAt(i);
          if (!eqs) {
            return false;
          }
          i += 1;
        }
        return true;
      }
    };

    Parser.prototype.interTerm = function(symbol) {
      var t;
      t = new Term(symbol, []);
      t.line = this.line;
      t.column = this.column;
      return t;
    };

    Parser.prototype.transition = function(nm) {
      return this.currentMode = nm;
    };

    Parser.prototype.pushMode = function(nm) {
      this.modes.push(this.currentMode);
      return this.transition(nm);
    };

    Parser.prototype.popMode = function() {
      return this.currentMode = this.modes.pop();
    };

    Parser.prototype.die = function(message, l, c) {
      if (l == null) {
        l = this.line;
      }
      if (c == null) {
        c = this.column;
      }
      throw new Error("line:" + l + " column:" + c + ", no, bad: " + message);
    };

    Parser.prototype.finishTakingSymbol = function() {
      this.foremostSymbol = this.stringBuffer;
      this.stringBuffer = '';
      return this.foremostSymbol;
    };

    Parser.prototype.finishTakingTermAndAttach = function() {
      this.foremostTerm = this.interTerm(this.finishTakingSymbol());
      if (this.containsImmediateNext) {
        this.containsImmediateNext.tail.push(this.foremostTerm);
        return this.containsImmediateNext = null;
      } else if (this.headTerm === null) {
        this.headTerm = this.foremostTerm;
        return this.tailestTermSequence = this.foremostTerm.tail;
      } else if (this.parenTermStack.length === 0) {
        return this.headTerm.tail.push(this.foremostTerm);
      } else {
        return this.parenTermStack[0].tail.push(this.foremostTerm);
      }
    };

    Parser.prototype.finishTakingIndentation = function() {
      this.salientIndentation = this.stringBuffer;
      this.stringBuffer = '';
      return this.salientIndentation;
    };

    Parser.prototype.finishLine = function() {
      if (this.salientIndentation.length > this.previousIndentation.length) {
        if (!startsWith(this.salientIndentation, this.previousIndentation)) {
          this.die("inconsistent indentation at", this.headTerm.line, this.headTerm.column);
        }
        this.indentStack.push([this.salientIndentation.length, this.previousTailestTermSequence]);
      } else if (this.salientIndentation.length < this.previousIndentation.length) {
        if (!startsWith(this.previousIndentation, this.salientIndentation)) {
          this.die("inconsistent indentation", this.headTerm.line, this.headTerm.column);
        }
        while (this.indentStack[this.indentStack.length - 1][0] > this.salientIndentation.length) {
          if (this.indentStack[this.indentStack.length - 1][0] < this.salientIndentation.length) {
            this.die("inconsistent indentation, sibling elements have different indentation", this.headTerm.line, this.headTerm.column);
          }
          this.indentStack.pop();
        }
      }
      this.indentStack[this.indentStack.length - 1][1].push(this.headTerm);
      this.containsImmediateNext = null;
      this.previousIndentation = this.salientIndentation;
      this.previousTailestTermSequence = this.tailestTermSequence;
      this.tailestTermSequence = this.resultSeq;
      this.parenTermStack = [];
      this.headTerm = null;
      return this.foremostTerm = null;
    };

    Parser.prototype.finishLineNormally = function() {
      this.finishLine();
      return this.transition(this.eatingIndentation);
    };

    Parser.prototype.closeParen = function() {
      if (this.parenTermStack.length === 0) {
        this.die("unbalanced paren");
      }
      this.parenTermStack.pop();
      return this.transition(this.seekingInLine);
    };

    Parser.prototype.openParen = function() {
      this.parenTermStack.push(this.foremostTerm);
      return this.transition(this.enteringParen);
    };

    Parser.prototype.eatingIndentation = function(c) {
      var stringBuffer;
      switch (c) {
        case '\n':
          return stringBuffer = '';
        case ':':
          return this.die("colon not allowed here");
        case '(':
          return this.die("what are you openingggg");
        case ')':
          return this.die("what are you closingggg");
        case '"':
          this.finishTakingIndentation();
          return this.transition(this.startingToTakeQuoteTerm);
        case ' ':
          return this.stringBuffer += c;
        case '\t':
          return this.stringBuffer += c;
        default:
          this.finishTakingIndentation();
          this.transition(this.takeTerm);
          return this.takeTerm(c);
      }
    };

    Parser.prototype.seekingInLine = function(c) {
      switch (c) {
        case '(':
          return this.openParen();
        case ')':
          return this.closeParen();
        case ':':
          this.containsImmediateNext = this.foremostTerm;
          return this.transition(this.seekingColonBuddy);
        case ' ':
          break;
        case '\t':
          break;
        case '\n':
          return this.finishLineNormally();
        case '"':
          return this.transition(this.startingToTakeQuoteTerm);
        default:
          this.transition(this.takeTerm);
          return this.takeTerm(c);
      }
    };

    Parser.prototype.takeTerm = function(c) {
      var breakToSeekingInline, containsImmediateNext;
      breakToSeekingInline = (function(_this) {
        return function() {
          _this.finishTakingTermAndAttach();
          _this.transition(_this.seekingInLine);
          return _this.seekingInLine(c);
        };
      })(this);
      switch (c) {
        case ' ':
          return breakToSeekingInline();
        case '\t':
          return breakToSeekingInline();
        case ':':
          return breakToSeekingInline();
        case '\n':
          return breakToSeekingInline();
        case '(':
          return breakToSeekingInline();
        case ')':
          return breakToSeekingInline();
        case '"':
          this.finishTakingTermAndAttach();
          containsImmediateNext = this.foremostTerm;
          return this.transition(this.startingToTakeQuoteTerm);
        default:
          return this.stringBuffer += c;
      }
    };

    Parser.prototype.enteringParen = function(c) {
      switch (c) {
        case ' ':
          break;
        case '\t':
          break;
        case ':':
          return this.die("colon wat");
        case '(':
          return this.die("paren opens nothing");
        case ')':
          return this.closeParen();
        case '"':
          return this.transition(this.takingSingleLineQuoteTerm);
        case '\n':
          return this.die("newline before paren completion (parens are only for single lines)");
        default:
          this.transition(this.takeTerm);
          return this.takeTerm(c);
      }
    };

    Parser.prototype.seekingColonBuddy = function(c) {
      switch (c) {
        case ' ':
          break;
        case '\t':
          break;
        case ':':
          return this.die("double colon wat");
        case '\n':
          this.tailestTermSequence = this.containsImmediateNext.tail;
          return this.finishLineNormally();
        case '(':
          return this.openParen();
        case ')':
          return this.die("closebracket after colon wat");
        case '"':
          return this.transition(this.startingToTakeQuoteTerm);
        default:
          this.transition(this.takeTerm);
          return this.takeTerm(c);
      }
    };

    Parser.prototype.startingToTakeQuoteTerm = function(c) {
      switch (c) {
        case '"':
          this.finishTakingTermAndAttach();
          return this.transition(this.seekingInLine);
        case '\n':
          if (!this.parenTermStack.length === 0) {
            die("newline with unbalanced parens(if you want multiline string syntax, that's an indented block under a single quote)");
          }
          this.stringBuffer = '';
          return this.transition(this.multiLineFirstLine);
        case ' ':
          return this.stringBuffer += c;
        case '\t':
          return this.stringBuffer += c;
        default:
          this.transition(this.takingSingleLineQuoteTerm);
          return this.takingSingleLineQuoteTerm(c);
      }
    };

    Parser.prototype.takingSingleLineQuoteTerm = function(c) {
      switch (c) {
        case '"':
          this.finishTakingTermAndAttach();
          return this.transition(this.seekingInLine);
        case '\\':
          return this.pushMode(this.takingEscape);
        case '\n':
          this.finishTakingTermAndAttach();
          this.transition(this.seekingInLine);
          return this.seekingInLine('\n');
        default:
          return this.stringBuffer += c;
      }
    };

    Parser.prototype.takingEscape = function(c) {
      switch (c) {
        case 'n':
          this.stringBuffer += '\n';
          break;
        case 'r':
          this.stringBuffer += '\r';
          break;
        case 't':
          this.stringBuffer += '\t';
          break;
        case 'h':
          this.stringBuffer += 'â˜ƒ';
          break;
        default:
          this.stringBuffer += c;
      }
      return this.popMode();
    };

    Parser.prototype.multiLineFirstLine = function(c) {
      switch (c) {
        case ' ':
          return this.multiLineIndent += c;
        case '\t':
          return this.multiLineIndent += c;
        default:
          this.mlIndent = this.multiLineIndent;
          if (this.mlIndent.length > this.salientIndentation.length) {
            if (startsWith(this.mlIndent, this.salientIndentation)) {
              this.multiLineIndent = '';
              this.transition(this.multiLineTakingText);
              return this.multiLineTakingText(c);
            } else {
              return this.die("inconsistent indentation");
            }
          } else {
            return this.die("multiline string must be indented");
          }
      }
    };

    Parser.prototype.multiLineTakingIndent = function(c) {
      var nin;
      if (c === ' ' || c === '\t') {
        return this.multiLineIndent += c;
      } else {
        nin = this.multiLineIndent;
        this.multiLineIndent = '';
        if (nin.length >= this.mlIndent.length) {
          if (startsWith(nin, this.mlIndent)) {
            this.stringBuffer += '\n';
            if (nin.length > this.mlIndent.length) {
              this.stringBuffer += this.mlIndent.substring(nin.length, this.mlIndent.length);
            }
            this.transition(this.multiLineTakingText);
            return this.multiLineTakingText(c);
          } else {
            return this.die("inconsistent indentation");
          }
        } else {
          if (startsWith(this.mlIndent, nin)) {
            this.finishTakingTermAndAttach();
            this.finishLine();
            this.salientIndentation = nin;
            this.transition(this.takeTerm);
            return this.takeTerm(c);
          } else {
            return this.die("inconsistent indentation");
          }
        }
      }
    };

    Parser.prototype.multiLineTakingText = function(c) {
      switch (c) {
        case '\n':
          return this.transition(this.multiLineTakingIndent);
        default:
          return this.stringBuffer += c;
      }
    };

    Parser.prototype.parse = function(s) {
      var c, res;
      this.transition(this.eatingIndentation);
      while (this.index < s.length) {
        c = s[this.index];
        if (c === '\r') {
          if (s[this.index + 1] === '\n') {
            this.index += 1;
          }
          c = '\n';
        }
        this.currentMode(c);
        this.index += 1;
        if (c === '\n') {
          this.line += 1;
          this.column = 0;
        } else {
          this.column += 1;
        }
      }
      if (s[s.length - 1] !== '\n') {
        this.currentMode('\n');
      }
      res = this.resultSeq;
      this.init();
      return res;
    };

    return Parser;

  })();

  parseTermpose = function(s) {
    return new Parser().parse(s);
  };

  exports.parseTermpose = parseTermpose;

  exports.Term = Term;

  exports.Parser = Parser;

}).call(this);

//# sourceMappingURL=termpose.js.map
